Messaging Project: 

EventArgs.cs:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Messaging
{
    public class VerifyScheduleEventArgs : EventArgs
    {
        public bool CanExecute { get; set; }
    }
}


IPublisher.cs:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Messaging
{
    public interface IPublisher
    {
        string HostName { get; }
        string QueueName { get; }
        void Connect();
        void Disconnect();
        void Publish(string messageBody);
    }
}


ISubscriber.cs:

using SMTBUSA.Messaging.Consumer;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Messaging
{
    public interface ISubscriber
    {
        event MQConsumer.MQMessageReceivedHandler MQMessageReceived;
        string HostName { get; }
        string QueueName { get; }
        void ConsumeMessages();
        void Connect();
        void StartListening();
        void StopListening();
    }
}


MessageBridge.cs:

using Microsoft.Extensions.Logging;

namespace Messaging
{
    public class MessageBridge
    {
        protected ISubscriber _sourceQueue;
        protected IPublisher _targetQueue;
        //private static ILog _logger = LogManager.GetLogger(typeof(MessageBridge));
        private readonly ILogger<MessageBridge> _logger;

        public delegate void ErrorHandler(object sender, Exception ex);
        public event ErrorHandler OnError;

        #region Constructor
        public MessageBridge(ISubscriber sourceQueue, IPublisher targetQueue, ILogger<MessageBridge> logger)
        {
            _logger = logger;
            _sourceQueue = sourceQueue;
            _sourceQueue.MQMessageReceived += Subscriber_MQMessageReceived;
            _targetQueue = targetQueue;
        }
        #endregion 

        #region Subscriber Events
        private void Subscriber_MQMessageReceived(object sender, SMTBUSA.Messaging.Consumer.MQMessageReceivedArgs msgArgs)
        {
            try
            {
                var msgBody = System.Text.Encoding.UTF8.GetString(msgArgs.MessageBody);
                _targetQueue.Publish(msgBody);
                msgArgs.IsAcknowledge = true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in MessageBridge");
                msgArgs.IsRejectMessage = true;
                throw;
            }
        }
        #endregion 

        #region Methods
        protected void RaiseError(Exception ex)
        {
            try
            {
                if (this.OnError != null)
                {
                    this.OnError(this, ex);
                }
            }
            catch (Exception)
            {
                throw;
            }
        }

        public virtual void Start()
        {
            try
            {
                _sourceQueue.StartListening();
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Unexpected error while start to listening the queue");
                throw;
            }
        }

        public virtual void Stop()
        {
            try
            {
                _logger.LogInformation("Stopping message bridge. SourceQueue. {0}, TargetQueue: {1}", _sourceQueue.QueueName, _targetQueue.QueueName);
                _sourceQueue.StopListening();
                _targetQueue.Disconnect();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error while stop lestening the queue");
            }
        }
        #endregion 
    }
}


ScheduledMessageBridge.cs:

using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Timers;
using System.Data.SqlClient;
using Microsoft.Extensions.Configuration;
using Dapper;

namespace Messaging
namespace Messaging.Processing
{
    public class ScheduledMessageBridge : MessageBridge
    public class MessageProcessor : IDisposable
    {
        private System.Timers.Timer _timer;
        //private static ILog _logger = LogManager.GetLogger(typeof(ScheduledMessageBridge));
        private readonly ILogger<ScheduledMessageBridge> _logger;
        private readonly ILogger<MessageProcessor> _logger;
        private readonly IConfiguration _configuration;
        private readonly System.Timers.Timer _inactivityTimer;
        private readonly object _lock = new object();

        public delegate void VerifyScheduleHandler(object sender, VerifyScheduleEventArgs args);
        public event VerifyScheduleHandler OnVerifySchedule;
        private const int InactivityIntervalInSeconds = 20;
        private bool _disposed = false;


        #region Constructor
        public ScheduledMessageBridge(ISubscriber sourceQueue, IPublisher targetQueue, double interval, ILogger<ScheduledMessageBridge> logger) : base(sourceQueue, targetQueue, logger)
        public MessageProcessor(ILogger<MessageProcessor> logger, IConfiguration configuration)
        {
            _logger = logger;
            _timer = new System.Timers.Timer() { Interval = interval };
            _timer.Elapsed += OnTimerElapsed;
        }
        #endregion 


        private bool CanConsumeMessages()
        {
            try
            {
                VerifyScheduleEventArgs args = new VerifyScheduleEventArgs();
                if (this.OnVerifySchedule != null)
                {
                    this.OnVerifySchedule(this, args);
                    return args.CanExecute;
                }
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error while ScheduledMessageBridge");
                throw;
            }
        }

        private void EnableTimer()
        {
            _timer.Enabled = true;
        }
            _configuration = configuration;

        private void DisableTimer()
        {
            _timer.Enabled = false;
            _inactivityTimer = new System.Timers.Timer(InactivityIntervalInSeconds * 1000);
            _inactivityTimer.Elapsed += OnTimerElapsed;
            _inactivityTimer.AutoReset = false; // Only fire once unless reset
        }

        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
        public void HandleMessage(string message)
        {
            try
            {
                this.DisableTimer();
                SaveMessageToTempTable(message);

                if (this.CanConsumeMessages())
                lock (_lock)
                {
                    _sourceQueue.ConsumeMessages();
                    _inactivityTimer.Stop();  // Reset timer
                    _inactivityTimer.Start(); // Start again
                }

            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error while ScheduledMessageBridge");
                this.RaiseError(ex);
            }
            finally
            {
                this.EnableTimer();
            }
        }

        public override void Start()
        {
            try
            {
                EnableTimer();
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Unexpected error while ScheduledMessageBridge");
                _logger.LogError(ex, "Failed to handle incoming message.");
            }
        }

        public override void Stop()
        private void SaveMessageToTempTable(string message)
        {
            try
            {
                DisableTimer();
                _sourceQueue.StopListening();
                _targetQueue.Disconnect();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error while ScheduledMessageBridge");
            }
        }
    }
}


Messaging.IBMMQ Project:

IBMMQClient.cs:

using IBM.WMQ;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Collections;
using System.Runtime;

namespace Messaging.IBMMQ
{
    public abstract class IBMMQClient : IDisposable
    {
        protected string _host;
        protected string _queueMgrName;
        protected string _queueName;
        protected string _channelName;
        protected MQQueueManager _queueMgr;
        protected MQQueue _queue;
        //private static ILog _logger = LogManager.GetLogger(typeof(IBMMQClient));
        private readonly ILogger<IBMMQClient> _logger;
        protected IBMMQConnectionSettings _ibmMQSettings;
            string connectionString = _configuration.GetConnectionString("Default");

            using var connection = new SqlConnection(connectionString);
            connection.Execute("INSERT INTO TempMessages (MessageContent, ReceivedAt) VALUES (@Message, GETDATE())",
                new { Message = message });

        #region Constructor
        public IBMMQClient(IOptions<IBMMQConnectionSettings> opts, ILogger<IBMMQClient> logger)
        {
            try
            {
                _ibmMQSettings = opts.Value;    
                _logger = logger;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQClient");
                throw;
            }
            _logger.LogInformation("Message stored to TempMessages table.");
        }
        #endregion

        #region Methods
        public virtual void Connect()
        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
        {
            try
            {
                _logger.LogInformation("20 seconds of inactivity reached. Executing stored procedure.");

                if ((_queueMgr != null) && (_queueMgr.OpenStatus == true) &&
                    (_queue != null) && (_queue.IsOpen))
                {
                    return;
                }

                Hashtable connectionProperties = new Hashtable();
                connectionProperties.Add(MQC.HOST_NAME_PROPERTY, _ibmMQSettings.HostName);
                connectionProperties.Add(MQC.CHANNEL_PROPERTY, _ibmMQSettings.Channel);
                connectionProperties.Add(MQC.TRANSPORT_PROPERTY, MQC.TRANSPORT_MQSERIES_MANAGED);
                connectionProperties.Add(MQC.PORT_PROPERTY, _ibmMQSettings.Port);

                if (!string.IsNullOrEmpty(_ibmMQSettings.UserID))
                {
                    connectionProperties.Add(MQC.USER_ID_PROPERTY, _ibmMQSettings.UserID);
                }

                if (!string.IsNullOrEmpty(_ibmMQSettings.Password))
                {
                    connectionProperties.Add(MQC.PASSWORD_PROPERTY, _ibmMQSettings.Password);
                }


                if (!string.IsNullOrEmpty(_ibmMQSettings.CertificateStore))
                {
                    connectionProperties.Add(MQC.SSL_CERT_STORE_PROPERTY, _ibmMQSettings.CertificateStore);

                    if (!string.IsNullOrEmpty(_ibmMQSettings.CipherSpec))
                    {
                        connectionProperties.Add(MQC.SSL_CIPHER_SPEC_PROPERTY, _ibmMQSettings.CipherSpec);
                    }

                    if (!string.IsNullOrEmpty(_ibmMQSettings.CipherSuite))
                    {
                        connectionProperties.Add(MQC.SSL_CIPHER_SUITE_PROPERTY, _ibmMQSettings.CipherSuite);
                    }
                }
                string connectionString = _configuration.GetConnectionString("Default");

                _queueMgr = new MQQueueManager(_ibmMQSettings.QueueManager, connectionProperties);
                _logger.LogDebug("Connected to queue manager. {0}", _ibmMQSettings.QueueManager);
                using var connection = new SqlConnection(connectionString);
                connection.Execute("EXEC dbo.ProcessMessages");

                _queueName = _ibmMQSettings.Queue;
                _queue = _queueMgr.AccessQueue(_queueName, MQC.MQOO_INPUT_AS_Q_DEF + MQC.MQOO_OUTPUT + MQC.MQOO_FAIL_IF_QUIESCING);
                _logger.LogDebug("Connected to queue. {0}", _ibmMQSettings.Queue);
                _logger.LogInformation("Stored procedure executed successfully.");
            }
            catch (Exception ex)
            {
                _logger.LogError("{0} {1}", ex.Message, ex.StackTrace);

                throw;
            }
        }

        public virtual void Disconnect()
        {
            if (_queue != null)
            {

                try
                {
                    _logger.LogInformation("Disconnecting IBM MQ client.");
                    _queue.Close();

                    _logger.LogInformation("IBM MQ queue {0} successfully closed", _queue.Name.Trim());
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("{0} {1}", ex.Message, ex.StackTrace);
                }
            }

            if (_queueMgr != null)
            {
                try
                {

                    _queueMgr.Disconnect();
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("{0} {1}", ex.Message, ex.StackTrace);
                }

                try
                {
                    _queueMgr.Close();
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("{0} {1}", ex.Message, ex.StackTrace);
                }
                _logger.LogInformation("IBM MQ queue manager successfully disconnected.");
                _logger.LogError(ex, "Failed to execute stored procedure.");
            }
        }

        public virtual void Reconnect()
        {
            try
            {
                _logger.LogDebug("Reconnect interval is set at {0}.", this._ibmMQSettings.ReconnectWaitInterval);
                this.Disconnect();
                this.ApplyDelayOnReconnect();
                this.Connect();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQClient");
            }
        }

        private void ApplyDelayOnReconnect()
        {
            try
            {
                if (this._ibmMQSettings.ReconnectWaitInterval > 0)
                {
                    Thread.Sleep(new TimeSpan(0, 0, this._ibmMQSettings.ReconnectWaitInterval));
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQClient");
            }
        }
        #endregion

        public void Dispose()
        {
            this.Disconnect();
            _queueMgr = null;
            _queue = null;
        }
    }
}

            if (_disposed) return;

IBMMQConnectionSettings.cs:

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Messaging.IBMMQ
{
    public class IBMMQConnectionSettings
    {
        public string HostName { get; set; }
        public int Port { get; set; }
        public string QueueManager { get; set; }
        public string Queue { get; set; }
        public string Channel { get; set; }

        public string UserID { get; set; }
        public string Password { get; set; }

        public string CertificateStore { get; set; }
        public string CipherSpec { get; set; }
        public string CipherSuite { get; set; }

        public int ReconnectWaitInterval { get; set; }
        public int IdleTimeout { get; set; }
    }
}


IBMMQPublisher.cs:

using IBM.WMQ;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Timers;

namespace Messaging.IBMMQ
{
    public class IBMMQPublisher : IBMMQClient, IPublisher
    {
        //private static ILog _logger = LogManager.GetLogger(typeof(IBMMQPublisher));
        private readonly ILogger<IBMMQPublisher> _logger;
        private System.Timers.Timer _idleTimeout;


        #region Constructor
        public IBMMQPublisher(IOptions<IBMMQConnectionSettings> ibmMQSettings, ILogger<IBMMQPublisher> logger) : base(ibmMQSettings, logger)
        {
            try
            {
                _logger = logger;
                _idleTimeout = new System.Timers.Timer();
                _idleTimeout.AutoReset = true;
                _idleTimeout.Elapsed += (object sender, ElapsedEventArgs e) =>
                {
                    this.DisableIdleTimeout();
                    this.Disconnect();
                };


            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        #endregion

        public string HostName
        {
            get
            {
                return _ibmMQSettings.HostName;
            }
        }

        private void DisableIdleTimeout()
        {
            try
            {
                _idleTimeout.Enabled = false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        private void EnableIdleTimeout()
        {
            try
            {
                if (_ibmMQSettings.IdleTimeout <= 0)
                {
                    return;
                }
                _idleTimeout.Interval = _ibmMQSettings.IdleTimeout * 1000;
                _idleTimeout.Enabled = true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        public void Publish(string messageBody)
        {
            try
            {
                this.DisableIdleTimeout();
                this.Connect();
                MQMessage mqMessage = new MQMessage();
                mqMessage.CharacterSet = 37;
                mqMessage.Encoding = 273;
                mqMessage.Write(Encoding.ASCII.GetBytes(messageBody));

                MQPutMessageOptions mqPutOptions = new MQPutMessageOptions();
                _queue.Put(mqMessage, mqPutOptions);

                _logger.LogInformation("Successfully published message to {0}", _queueName);
                _logger.LogDebug("MessageBody : {0}", messageBody);

                this.EnableIdleTimeout();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        public string QueueName
        {
            get { return _queueName; }
            _inactivityTimer?.Dispose();
            _disposed = true;
        }
    }
}


IBMMQSubscriber.cs:

using IBM.WMQ;
using IBM.WMQ.Nmqi;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SMTBUSA.Messaging.Consumer;

namespace Messaging.IBMMQ
{
    public class IBMMQSubscriber : IBMMQClient, ISubscriber
    {
        private Task _listenTask = null;
        private CancellationTokenSource _cancelListenTokenSource = new CancellationTokenSource();
        public event SMTBUSA.Messaging.Consumer.MQConsumer.MQMessageReceivedHandler MQMessageReceived;

        //private static ILog _logger = LogManager.GetLogger(typeof(IBMMQSubscriber));
        private readonly ILogger<IBMMQSubscriber> _logger;

        #region Constructor
        public IBMMQSubscriber(IOptions<IBMMQConnectionSettings> ibmMQSettings, ILogger<IBMMQSubscriber> logger) : base(ibmMQSettings, logger)
        {
            _logger = logger;
        }
        #endregion 

        public string HostName
        {
            get
            {
                return _ibmMQSettings.HostName;
            }
        }

        public string QueueName
        {
            get { return _queueName; }
        }
        public void StartListening()
        {
            this.Connect();
            
        }

        public void StopListening()
        {
            try
            {
                _cancelListenTokenSource.Cancel();

                this.Disconnect();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                throw;
            }
        }

        public void ConsumeMessages()
        {
            try
            {
                this.Connect();

                while (true)
                {
                    MQMessage incomingMsg = new MQMessage();
                    incomingMsg.CorrelationId = MQC.MQMI_NONE;
                    incomingMsg.MessageId = MQC.MQMI_NONE;

                    try
                    {
                        _logger.LogDebug("Checking IBM MQ for messages. Queue: {0}", _queue.Name);
                        MQGetMessageOptions mqGetMsgOptions = new MQGetMessageOptions() { Options = MQC.MQGMO_WAIT }; //accept the defaults
                        _queue.Get(incomingMsg, mqGetMsgOptions);
                    }
                    catch (MQException mqException)
                    {
                        if (mqException.Reason != MQC.MQRC_NO_MSG_AVAILABLE)
                        {
                            _logger.LogWarning(mqException, _queue.Name);
                        }
                        break;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                        break;
                    }


                    if (incomingMsg == null)
                    {
                        break;
                    }

                    if ((incomingMsg != null) && (MQMessageReceived != null))
                    {
                        string msgText = incomingMsg.ReadString(incomingMsg.MessageLength);
                        _logger.LogInformation("IBM MQ subscriber message detected. Character set: {0}, Encoding: {1}", incomingMsg.CharacterSet, incomingMsg.Encoding);
                        _logger.LogDebug("IBM MQ message received : {0}", msgText);
                        MQMessageReceived(this, new MQMessageReceivedArgs() { MessageBody = System.Text.Encoding.UTF8.GetBytes(msgText) });
                    }
                }

            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                throw;
            }
            finally
            {
                this.Disconnect();
            }
        }
    }
}


IBMMQSubscriber Console App Project:

appsettings.json:

{
  "IBMMQConnectionSettings": {
    "HostName": "HBWCDP01",
    "Port": 1411,
    "QueueManager": "CDS.OUT.LOCAL.DEV",
    "Queue": "CASHMOV.REQUEST",
    "Channel": "CDS.INTERNAL.SVRCONN",
    "UserID": "cdsmquser",
    "Password": "Welcome@0924",
    "CertificateStore": "",
    "CipherSpec": "",
    "CipherSuite": "",
    "ReconnectWaitInterval": 30
  }
}


Program.cs:

using Messaging;
using Messaging.IBMMQ;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Subscriber;

var host = Host.CreateDefaultBuilder(args)
.ConfigureAppConfiguration(cfg => cfg.AddJsonFile("appsettings.json"))
.ConfigureServices((ctx, services) =>
{
    services.Configure<IBMMQConnectionSettings>(ctx.Configuration.GetSection("IBMMQConnectionSettings"));
    //services.AddTransient<IBMMQClient>();
    services.AddTransient<ISubscriber, IBMMQSubscriber>();
    services.AddHostedService<SubscriberWorker>();
}).ConfigureLogging(logging =>
{
    logging.ClearProviders();
    logging.AddConsole();
    logging.SetMinimumLevel(LogLevel.Information);
})
.Build();

await host.StartAsync();


SubscriberWorker.cs:

using Messaging;
using Messaging.IBMMQ;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Subscriber
{
    public class SubscriberWorker : BackgroundService
    {
        private readonly ISubscriber _subscriber;
        private readonly ILogger<SubscriberWorker> _logger;
        protected IBMMQConnectionSettings _ibmMQSettings;
        public SubscriberWorker(IOptions<IBMMQConnectionSettings> ibmMQSettings, ISubscriber subscriber, ILogger<SubscriberWorker> logger)
        {
            _ibmMQSettings = ibmMQSettings.Value;
            _subscriber = subscriber;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken ct)
        {
            _logger.LogInformation("Subscriber started, listening to " + _ibmMQSettings.Queue);
            _subscriber.StartListening();

            while(!ct.IsCancellationRequested)
            {
                if (_logger.IsEnabled(LogLevel.Information))
                {
                    _logger.LogInformation("Subscriber Worker running at: {time}", DateTimeOffset.Now);
                }
                await Task.Delay(1000, ct);
            }
        }

    }
}



IBMMQPublisher Console App Project:

appsettings.json:
{
  "IBMMQConnectionSettings": {
    "HostName": "HBWCDP01",
    "Port": 1411,
    "QueueManager": "CDS.OUT.LOCAL.DEV",
    "Queue": "CASHMOV.REQUEST",
    "Channel": "CDS.INTERNAL.SVRCONN",
    "UserID": "cdsmquser",
    "Password": "Welcome@0924",
    "CertificateStore": "",
    "CipherSpec": "",
    "CipherSuite": "",
    "ReconnectWaitInterval": 30
  }
}


Program.cs:

using Messaging;
using Messaging.IBMMQ;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Publisher;

var host = Host.CreateDefaultBuilder(args)
.ConfigureAppConfiguration(cfg => cfg.AddJsonFile("appsettings.json"))
.ConfigureServices((ctx, services) =>
{
    services.Configure<IBMMQConnectionSettings>(ctx.Configuration.GetSection("IBMMQConnectionSettings"));
    //services.AddTransient<IBMMQClient>();
    services.AddTransient<IPublisher, IBMMQPublisher>();
    services.AddHostedService<PublisherWorker>();
}).ConfigureLogging(logging =>
{
    logging.ClearProviders();
    logging.AddConsole();
    logging.SetMinimumLevel(LogLevel.Information);
})
.Build();

await host.StartAsync();
await host.WaitForShutdownAsync();


PublisherWorker.cs:

using Messaging;
using Messaging.IBMMQ;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Publisher
{
    public class PublisherWorker : BackgroundService
    {
        private readonly IPublisher _publisher;
        private readonly ILogger<PublisherWorker> _logger;
        protected IBMMQConnectionSettings _ibmMQSettings;
        public PublisherWorker(IOptions<IBMMQConnectionSettings> ibmMQSettings, IPublisher publisher, ILogger<PublisherWorker> logger)
        {
            _ibmMQSettings = ibmMQSettings.Value;
            _publisher = publisher;
            _logger = logger;
        }

        protected override async Task ExecuteAsync(CancellationToken ct)
        {
            _logger.LogInformation("publisher started, sending to " + _ibmMQSettings.Queue);

            int counter = 1;
            while (!ct.IsCancellationRequested)
            {
                string message = $"Test Message {counter} at {DateTimeOffset.Now}";
                _publisher.Publish(message);                
                _logger.LogInformation("Published: {Message}", message);

                counter++;
                await Task.Delay(1000, ct);
            }
        }

    }
}
