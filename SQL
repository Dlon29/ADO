I have created this project in .Net 9, follwing is the structure:

MessageProcessing.Publisher:

appsettings.json:

{
  "IBMMQConnectionSettings": {
    "HostName": "HBWCDP01",
    "Port": 1411,
    "QueueManager": "CDS.OUT.LOCAL.DEV",
    "Queue": "CASHMOV.REQUEST",
    "Channel": "CDS.INTERNAL.SVRCONN",
    "UserID": "cdsmquser",
    "Password": "Welcome@0924",
    "CertificateStore": "",
    "CipherSpec": "",
    "CipherSuite": "",
    "ReconnectWaitInterval": 30
  }
}

Program.cs:

using Messaging.IBMMQ;
using Messaging.IBMMQ.Shared.Interface;
using Messaging.IBMMQ.Shared.Models;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

var host = Host.CreateDefaultBuilder(args)
.ConfigureAppConfiguration(cfg => cfg.AddJsonFile("appsettings.json"))
.ConfigureServices((ctx, services) =>
{
    services.Configure<IBMMQConnectionSettings>(ctx.Configuration.GetSection("IBMMQConnectionSettings"));
    services.AddTransient<IPublisher, IBMMQPublisher>();
    //services.AddTransient<IBMMQClient>();
}).ConfigureLogging(logging =>
{
    logging.ClearProviders();
    logging.AddConsole();
    logging.SetMinimumLevel(LogLevel.Information);
})
.Build();

var client = host.Services.GetRequiredService<IPublisher>();
await client.Publish(new Payload
{
    CorrelationId = "Test1",
    Body = "Hello World"
}, CancellationToken.None);


MessageProcessing.Shared:

IETLTriggerScheduler.cs:

namespace MessageProcessing.Shared.Interface
{
    public interface IETLTriggerScheduler
    {
        void Start();
    }
}


IRepository.cs:

using Messaging.IBMMQ.Shared.Models;

namespace MessageProcessing.Shared.Interface
{
    public interface IRepository
    {
        Task StagingInsert(Payload msg, DateTime enqueueUtc, string source, CancellationToken ct);
        Task ETLProcess(CancellationToken ct = default);
    }
}



AppSettings.cs:

namespace MessageProcessing.Shared.Models
{
    public class AppSettings
    {
        public int DelayInterval { get; set; }  
    }
}



ETLOptions.cs:

namespace MessageProcessing.Shared.Models
{
    public class EtlOptions
    {
        public int TimeoutSeconds { get; set; }  
    }
}



MessageProcessing.Subscriber:

apsettings.json:

{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },

  "IBMMQConnectionSettings": {
    "HostName": "HBWCDP01",
    "Port": 1411,
    "QueueManager": "CDS.OUT.LOCAL.DEV",
    "Queue": "CASHMOV.REQUEST",
    "Channel": "CDS.INTERNAL.SVRCONN",
    "UserID": "cdsmquser",
    "Password": "Welcome@0924",
    "CertificateStore": "",
    "CipherSpec": "",
    "CipherSuite": "",
    "ReconnectWaitInterval": 30
  },
  "ConnectionStrings": {
    "Sql": "Initial Catalog=lava;Data Source=THWDBD11.smtbusa.us,4433;Database=LAVA;uid=appuser; pwd=Madison527;Encrypt=false;TrustServerCertificate=true"
  },
  "Etl": {
    "TimeoutSeconds": 20
  },
  "AppSettings": {
    "DelayInterval": 1
  }
}



Repository.cs:

using MessageProcessing.Shared.Interface;
using Messaging.IBMMQ.Shared.Models;
using Microsoft.Data.SqlClient;

namespace MessageProcessing.Subscriber.Repositories
{
    public class Repository : IRepository
    {
        private readonly ILogger<Repository> _logger;
        private readonly string _connString;
        public Repository(IConfiguration cfg, ILogger<Repository> logger)
        {
            _connString = cfg.GetConnectionString("Sql");
            _logger = logger;
        }
        public async Task StagingInsert(Payload msg, DateTime enqueueUtc, string source, CancellationToken ct)
        {
            _logger.LogInformation("Persisting subscribed message into staging table");

            try
            {
                using var conn = new SqlConnection(_connString);
                using var cmd = new SqlCommand("dbo.p_Staging_Insert", conn)
                {
                    CommandType = System.Data.CommandType.StoredProcedure
                };

                cmd.Parameters.AddWithValue("@CorrelationId", msg.CorrelationId);
                cmd.Parameters.AddWithValue("@Body", msg.Body);
                cmd.Parameters.AddWithValue("@Source", source);
                cmd.Parameters.AddWithValue("@EnqueueUtc", enqueueUtc);

                conn.OpenAsync(ct).GetAwaiter().GetResult();
                cmd.ExecuteNonQueryAsync(ct).GetAwaiter().GetResult();
            }
            catch (Exception ex)
            {
                _logger.LogError("{0} {1}", "Error while staging insert " + ex.Message, ex.StackTrace);
            }

        }

        public async Task ETLProcess(CancellationToken ct)
        {
            _logger.LogInformation("Timer elapsed - Running ETL Process...");

            try
            {
                using var conn = new SqlConnection(_connString);
                using var cmd = new SqlCommand("dbo.p_Process_ETL", conn)
                {
                    CommandType = System.Data.CommandType.StoredProcedure
                };

                conn.OpenAsync(ct).GetAwaiter().GetResult();
                cmd.ExecuteNonQueryAsync(ct).GetAwaiter().GetResult();
            }
            catch (Exception ex)
            {
                _logger.LogError("{0} {1}", "Error while ETL Process " + ex.Message, ex.StackTrace);
            }

            _logger.LogInformation("ETL Process Completed");

        }
    }
}


ETLTriggerScheduler.cs:

using MessageProcessing.Shared.Interface;
using MessageProcessing.Shared.Models;
using Microsoft.Extensions.Options;

namespace MessageProcessing.Subscriber.UnitOfWork
{
    public class ETLTriggerScheduler : IETLTriggerScheduler, IDisposable
    {
        private readonly TimeSpan _timeout;        
        private readonly IRepository _repo;
        private readonly object _lock = new object();
        private Timer _timer;

        public ETLTriggerScheduler(IOptions<EtlOptions> opts, IRepository repo)
        {
            _timeout = TimeSpan.FromSeconds(opts.Value.TimeoutSeconds);
            _repo = repo;
        }

        public void Start()
        {
            lock (_lock)
            {
                _timer?.Change(Timeout.Infinite, Timeout.Infinite);
                _timer = new Timer(OnElapsed, null, _timeout, Timeout.InfiniteTimeSpan);
            }
        }

        private async void OnElapsed(object obj)
        {
            await _repo.ETLProcess(CancellationToken.None);
        }

        public void Dispose()
        {
            _timer?.Dispose();
        }
    }
}





Program.cs:

using MediatR;
using MessageProcessing.Shared.Interface;
using MessageProcessing.Shared.Models;
using MessageProcessing.Subscriber;
using MessageProcessing.Subscriber.Repositories;
using MessageProcessing.Subscriber.UnitOfWork;
using Messaging.IBMMQ;
using Messaging.IBMMQ.Shared.Interface;
using Messaging.IBMMQ.Shared.Models;
using MessagingProcessing.Handler;

var host = Host.CreateDefaultBuilder(args)
.ConfigureAppConfiguration(cfg => cfg.AddJsonFile("appsettings.json"))
.ConfigureServices((ctx, services) =>
{
    services.Configure<IBMMQConnectionSettings>(ctx.Configuration.GetSection("IBMMQConnectionSettings"));
    services.Configure<EtlOptions>(ctx.Configuration.GetSection("Etl"));
    services.Configure<AppSettings>(ctx.Configuration.GetSection("AppSettings")); 
    //services.AddTransient<IBMMQClient>();
    services.AddTransient<ISubscriber, IBMMQSubscriber>();
    services.AddTransient<Messaging.IBMMQ.Shared.Interface.IPublisher, IBMMQPublisher>();    
    services.AddTransient<IRepository, Repository>();
    services.AddTransient<IETLTriggerScheduler, ETLTriggerScheduler>();    
    services.AddMediatR(typeof(ProcessRequestCommandHandler).Assembly);
    services.AddHostedService<SubscriberWorker>();
}).ConfigureLogging(logging =>
{
    logging.ClearProviders();
    logging.AddConsole();
    logging.SetMinimumLevel(LogLevel.Trace);
    logging.AddLog4Net("log4net.config");
})
.Build();

await host.StartAsync();



SubscriberWorker.cs:

using MediatR;
using MessageProcessing.Shared.Models;
using Messaging.IBMMQ.Shared.Interface;
using Messaging.IBMMQ.Shared.Models;
using MessagingProcessing.Handler;
using Microsoft.Extensions.Options;

namespace MessageProcessing.Subscriber
{
    public class SubscriberWorker : BackgroundService
    {
        private readonly ILogger<SubscriberWorker> _logger;
        private readonly ISubscriber _subscriber;
        private readonly IMediator _mediator;
        protected IBMMQConnectionSettings _ibmMQSettings;
        protected AppSettings _appSettings;

        public SubscriberWorker(ILogger<SubscriberWorker> logger, IMediator mediator, IOptions<IBMMQConnectionSettings> ibmMQSettings, ISubscriber subscriber, IOptions<AppSettings> appSettings)
        {
            _logger = logger;
            _mediator = mediator;
            _ibmMQSettings = ibmMQSettings.Value;
            _subscriber = subscriber;
            _appSettings = appSettings.Value;
        }

        protected override async Task ExecuteAsync(CancellationToken ct)
        {
            _logger.LogInformation("Subscriber service started...");

            try
            {
                while (!ct.IsCancellationRequested)
                {
                    try
                    {
                        foreach (Payload msg in _subscriber.ReadMessages(ct))
                        {
                            try
                            {
                                _logger.LogInformation("Received message {CorrelationId}", msg.CorrelationId);
                                await _mediator.Send(new ProcessRequestCommand(msg), ct);
                            }
                            catch (Exception ex)
                            {
                                _logger.LogError(ex, "Error while processing messages {CorrelatioId}", msg.CorrelationId);
                            }
                        }

                        _logger.LogInformation("Subscriber Worker running at: {time}", DateTimeOffset.Now);
                        Task.Delay(TimeSpan.FromSeconds(_appSettings.DelayInterval), ct).GetAwaiter().GetResult();
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error while reading messages from subscriber, retrying in 5s...");
                        Task.Delay(TimeSpan.FromSeconds(_ibmMQSettings.ReconnectWaitInterval), ct).GetAwaiter().GetResult();
                    }
                }

            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("IBM MQ Subscriber no longer listening to messages on {0}", _ibmMQSettings.Queue);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in the worker loop");
                throw;
            }

            _logger.LogInformation("Subscriber service stopped...");
        }
    }
}



Messaging.IBMMQ:

IBMMQClient.cs:

using IBM.WMQ;
using Messaging.IBMMQ.Shared.Models;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Collections;

namespace Messaging.IBMMQ
{
    public abstract class IBMMQClient : IDisposable
    {
        protected string _host;
        protected string _queueMgrName;
        protected string _queueName;
        protected string _channelName;
        protected MQQueueManager _queueMgr;
        protected MQQueue _queue;
        //private static ILog _logger = LogManager.GetLogger(typeof(IBMMQClient));
        private readonly ILogger<IBMMQClient> _logger;
        protected IBMMQConnectionSettings _ibmMQSettings;


        #region Constructor
        public IBMMQClient(IOptions<IBMMQConnectionSettings> opts, ILogger<IBMMQClient> logger)
        {
            try
            {
                _ibmMQSettings = opts.Value;
                _logger = logger;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQClient");
                throw;
            }
        }
        #endregion

        #region Methods
        
        public virtual void Connect()
        {
            try
            {

                if ((_queueMgr != null) && (_queueMgr.OpenStatus == true) &&
                    (_queue != null) && (_queue.IsOpen))
                {
                    return;
                }

                Hashtable connectionProperties = new Hashtable();
                connectionProperties.Add(MQC.HOST_NAME_PROPERTY, _ibmMQSettings.HostName);
                connectionProperties.Add(MQC.CHANNEL_PROPERTY, _ibmMQSettings.Channel);
                connectionProperties.Add(MQC.TRANSPORT_PROPERTY, MQC.TRANSPORT_MQSERIES_MANAGED);
                connectionProperties.Add(MQC.PORT_PROPERTY, _ibmMQSettings.Port);

                if (!string.IsNullOrEmpty(_ibmMQSettings.UserID))
                {
                    connectionProperties.Add(MQC.USER_ID_PROPERTY, _ibmMQSettings.UserID);
                }

                if (!string.IsNullOrEmpty(_ibmMQSettings.Password))
                {
                    connectionProperties.Add(MQC.PASSWORD_PROPERTY, _ibmMQSettings.Password);
                }


                if (!string.IsNullOrEmpty(_ibmMQSettings.CertificateStore))
                {
                    connectionProperties.Add(MQC.SSL_CERT_STORE_PROPERTY, _ibmMQSettings.CertificateStore);

                    if (!string.IsNullOrEmpty(_ibmMQSettings.CipherSpec))
                    {
                        connectionProperties.Add(MQC.SSL_CIPHER_SPEC_PROPERTY, _ibmMQSettings.CipherSpec);
                    }

                    if (!string.IsNullOrEmpty(_ibmMQSettings.CipherSuite))
                    {
                        connectionProperties.Add(MQC.SSL_CIPHER_SUITE_PROPERTY, _ibmMQSettings.CipherSuite);
                    }
                }

                _queueMgr = new MQQueueManager(_ibmMQSettings.QueueManager, connectionProperties);
                _logger.LogDebug("Connected to queue manager. {0}", _ibmMQSettings.QueueManager);

                _queueName = _ibmMQSettings.Queue;
                _queue = _queueMgr.AccessQueue(_queueName, MQC.MQOO_INPUT_AS_Q_DEF + MQC.MQOO_OUTPUT + MQC.MQOO_FAIL_IF_QUIESCING);
                _logger.LogDebug("Connected to queue. {0}", _ibmMQSettings.Queue);
            }
            catch (Exception ex)
            {
                _logger.LogError("{0} {1}", ex.Message, ex.StackTrace);

                throw;
            }
        }

        public virtual void Disconnect()
        {
            if (_queue != null)
            {

                try
                {
                    _logger.LogInformation("Disconnecting IBM MQ client.");
                    _queue.Close();

                    _logger.LogInformation("IBM MQ queue {0} successfully closed", _queue.Name.Trim());
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("{0} {1}", ex.Message, ex.StackTrace);
                }
            }

            if (_queueMgr != null)
            {
                try
                {

                    _queueMgr.Disconnect();
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("{0} {1}", ex.Message, ex.StackTrace);
                }

                try
                {
                    _queueMgr.Close();
                }
                catch (Exception ex)
                {
                    _logger.LogWarning("{0} {1}", ex.Message, ex.StackTrace);
                }
                _logger.LogInformation("IBM MQ queue manager successfully disconnected.");
            }
        }

        public virtual void Reconnect()
        {
            try
            {
                _logger.LogDebug("Reconnect interval is set at {0}.", this._ibmMQSettings.ReconnectWaitInterval);
                this.Disconnect();
                this.ApplyDelayOnReconnect();
                //this.Connect();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQClient");
            }
        }

        private void ApplyDelayOnReconnect()
        {
            try
            {
                if (this._ibmMQSettings.ReconnectWaitInterval > 0)
                {
                    Thread.Sleep(new TimeSpan(0, 0, this._ibmMQSettings.ReconnectWaitInterval));
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQClient");
            }
        }
        #endregion

        public void Dispose()
        {
            this.Disconnect();
            _queueMgr = null;
            _queue = null;
        }
    }
}


IBMMQPublisher.cs:

using IBM.WMQ;
using Messaging.IBMMQ.Shared.Interface;
using Messaging.IBMMQ.Shared.Models;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Text;
using System.Timers;

namespace Messaging.IBMMQ
{
    public class IBMMQPublisher : IBMMQClient, IPublisher
    {
        //private static ILog _logger = LogManager.GetLogger(typeof(IBMMQPublisher));
        private readonly ILogger<IBMMQPublisher> _logger;
        private System.Timers.Timer _idleTimeout;


        #region Constructor
        public IBMMQPublisher(IOptions<IBMMQConnectionSettings> ibmMQSettings, ILogger<IBMMQPublisher> logger) : base(ibmMQSettings, logger)
        {
            try
            {
                _logger = logger;
                _idleTimeout = new System.Timers.Timer();
                _idleTimeout.AutoReset = true;
                _idleTimeout.Elapsed += (object sender, ElapsedEventArgs e) =>
                {
                    this.DisableIdleTimeout();
                    this.Disconnect();
                };


            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        #endregion

        public string HostName
        {
            get
            {
                return _ibmMQSettings.HostName;
            }
        }

        private void DisableIdleTimeout()
        {
            try
            {
                _idleTimeout.Enabled = false;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        private void EnableIdleTimeout()
        {
            try
            {
                if (_ibmMQSettings.IdleTimeout <= 0)
                {
                    return;
                }
                _idleTimeout.Interval = _ibmMQSettings.IdleTimeout * 1000;
                _idleTimeout.Enabled = true;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        public void Publish(string messageBody)
        {
            try
            {
                this.DisableIdleTimeout();
                this.Connect();
                MQMessage mqMessage = new MQMessage();
                mqMessage.CharacterSet = 37;
                mqMessage.Encoding = 273;
                mqMessage.Write(Encoding.ASCII.GetBytes(messageBody));

                MQPutMessageOptions mqPutOptions = new MQPutMessageOptions();
                _queue.Put(mqMessage, mqPutOptions);

                _logger.LogInformation("Successfully published message to {0}", _queueName);
                _logger.LogDebug("MessageBody : {0}", messageBody);

                this.EnableIdleTimeout();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
        }

        public Task Publish(Payload msg, CancellationToken ct)
        {
            try
            {
                this.DisableIdleTimeout();

                Connect();

                MQMessage mqMessage = new MQMessage();
                mqMessage.CharacterSet = 1208;
                mqMessage.Encoding = 273;
                mqMessage.Write(Encoding.UTF8.GetBytes(msg.Body));

                if (!string.IsNullOrEmpty(msg.CorrelationId))
                    mqMessage.CorrelationId = Encoding.UTF8.GetBytes(msg.CorrelationId);
                //mqMessage.WriteString(msg.Body);

                MQPutMessageOptions mqPutOptions = new MQPutMessageOptions();
                _queue.Put(mqMessage, mqPutOptions);

                _logger.LogInformation("Successfully published message to {0}", _queueName);
                _logger.LogDebug("MessageBody : {0}", msg.Body);

                this.EnableIdleTimeout();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQPublisher");
                throw;
            }
            return Task.CompletedTask;
        }



        public string QueueName
        {
            get { return _queueName; }
        }
    }
}



IBMMQSubscriber.cs:

using IBM.WMQ;
using Messaging.IBMMQ.Shared.Interface;
using Messaging.IBMMQ.Shared.Models;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using SMTBUSA.Messaging.Consumer;
using System.Runtime.CompilerServices;
using System.Text;

namespace Messaging.IBMMQ
{
    public class IBMMQSubscriber : IBMMQClient, ISubscriber
    {
        private Task _listenTask = null;
        private CancellationTokenSource _cancelListenTokenSource = new CancellationTokenSource();
        public event MQConsumer.MQMessageReceivedHandler MQMessageReceived;

        //private static ILog _logger = LogManager.GetLogger(typeof(IBMMQSubscriber));
        private readonly ILogger<IBMMQSubscriber> _logger;

        #region Constructor
        public IBMMQSubscriber(IOptions<IBMMQConnectionSettings> ibmMQSettings, ILogger<IBMMQSubscriber> logger) : base(ibmMQSettings, logger)
        {
            _logger = logger;
            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
        }
        #endregion 

        public string HostName
        {
            get
            {
                return _ibmMQSettings.HostName;
            }
        }

        public string QueueName
        {
            get { return _queueName; }
        }
        public void StartListening()
        {
            try
            {

                if ((_listenTask != null) && (_listenTask.Status == TaskStatus.Running))
                {
                    return;
                }

                CancellationToken cancelListenToken = _cancelListenTokenSource.Token;

                _listenTask = Task.Factory.StartNew(() =>
                {
                    try
                    {
                        this.Connect();

                        while (true)
                        {
                            cancelListenToken.ThrowIfCancellationRequested();
                            ConsumeMessages();
                        }
                    }
                    catch (OperationCanceledException)
                    {
                        _logger.LogInformation("IBM MQ Subscriber no longer listening to messages on {0}", _ibmMQSettings.Queue);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                        throw;
                    }
                }, cancelListenToken);

                //_listenTask.Start();
            }

            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                throw;
            }
        }

        public void StopListening()
        {
            try
            {
                _cancelListenTokenSource.Cancel();

                this.Disconnect();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                throw;
            }
        }

        public void ConsumeMessages()
        {
            try
            {
                this.Connect();

                while (true)
                {
                    MQMessage incomingMsg = new MQMessage();
                    incomingMsg.CorrelationId = MQC.MQMI_NONE;
                    incomingMsg.MessageId = MQC.MQMI_NONE;

                    try
                    {
                        _logger.LogDebug("Checking IBM MQ for messages. Queue: {0}", _queue.Name);
                        MQGetMessageOptions mqGetMsgOptions = new MQGetMessageOptions() { Options = MQC.MQGMO_WAIT }; //accept the defaults
                        _queue.Get(incomingMsg, mqGetMsgOptions);
                    }
                    catch (MQException mqException)
                    {
                        if (mqException.Reason != MQC.MQRC_NO_MSG_AVAILABLE)
                        {
                            _logger.LogWarning(mqException, _queue.Name);
                        }
                        break;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                        break;
                    }


                    if (incomingMsg == null)
                    {
                        break;
                    }

                    if ((incomingMsg != null) && (MQMessageReceived != null))
                    {
                        string msgText = incomingMsg.ReadString(incomingMsg.MessageLength);
                        _logger.LogInformation("IBM MQ subscriber message detected. Character set: {0}, Encoding: {1}", incomingMsg.CharacterSet, incomingMsg.Encoding);
                        _logger.LogDebug("IBM MQ message received : {0}", msgText);
                        MQMessageReceived(this, new MQMessageReceivedArgs() { MessageBody = System.Text.Encoding.UTF8.GetBytes(msgText) });
                    }
                }

            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Unexpected error in IBMMQSubscriber");
                throw;
            }
            finally
            {
                this.Disconnect();
            }
        }

        public IEnumerable<Payload> ReadMessages(CancellationToken ct)
        {
            Connect();
            
            var msg = new MQMessage();
            msg.CorrelationId = MQC.MQMI_NONE;
            msg.MessageId = MQC.MQMI_NONE;

            Encoding encoding;
            string corr = string.Empty;

            while (!ct.IsCancellationRequested)
            {
                try
                {
                    _logger.LogInformation("Checking IBM MQ for messages. Queue: {0}", _queue.Name);
                    var getOpts = new MQGetMessageOptions() { Options = MQC.MQGMO_WAIT }; //accept the defaults;
                    _queue.Get(msg, getOpts);
                }
                catch (MQException mqException)
                {
                    if (mqException.Reason != MQC.MQRC_NO_MSG_AVAILABLE)
                    {
                        _logger.LogWarning(mqException, "Unexpected MQ Error");
                    }
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Unexpected MQ Error");
                    break;
                }

                switch (msg.CharacterSet)
                {
                    case 37:    // EBCDIC
                        encoding = Encoding.GetEncoding(37);
                        break;
                    case 1200:  // UTF-16 LE
                        encoding = Encoding.Unicode;
                        break;
                    case 1201:  // UTF-16 BE
                        encoding = Encoding.BigEndianUnicode;
                        break;
                    case 1208:  // UTF-8
                        encoding = Encoding.UTF8;
                        break;
                    default:
                        encoding = Encoding.ASCII;
                        break;
                }
                byte[] buffer = new byte[msg.MessageLength];
                msg.ReadFully(ref buffer);

                string body = encoding.GetString(buffer).TrimEnd('\0');
                //var body = msg.ReadString(msg.MessageLength);

                if (msg.CorrelationId != null && msg.CorrelationId.Length > 0)
                    corr = Encoding.UTF8.GetString(msg.CorrelationId).TrimEnd('\0');

                _logger.LogInformation("IBM MQ subscriber message detected. Character set: {0}, Encoding: {1}", msg.CharacterSet, msg.Encoding);
                _logger.LogDebug("IBM MQ message received : {0}", body);


                yield return new Payload { CorrelationId = corr, Body = body };
            }

        }
    }
}



Messaging.IBMMQ.Shared:

IPublisher.cs:

using Messaging.IBMMQ.Shared.Models;

namespace Messaging.IBMMQ.Shared.Interface
{
    public interface IPublisher
    {
        string HostName { get; }
        string QueueName { get; }
        void Connect();
        void Disconnect();
        void Publish(string messageBody);
        Task Publish(Payload msg, CancellationToken ct);
    }
}


ISubscriber.cs:

using Messaging.IBMMQ.Shared.Models;
using SMTBUSA.Messaging.Consumer;

namespace Messaging.IBMMQ.Shared.Interface
{
    public interface ISubscriber
    {
        event MQConsumer.MQMessageReceivedHandler MQMessageReceived;
        string HostName { get; }
        string QueueName { get; }
        void ConsumeMessages();
        void Connect();
        void StartListening();
        void StopListening();
        IEnumerable<Payload> ReadMessages(CancellationToken ct);
    }
}


IBMMQConnectionSettings.cs:

namespace Messaging.IBMMQ.Shared.Models
{
    public class IBMMQConnectionSettings
    {
        public string HostName { get; set; }
        public int Port { get; set; }
        public string QueueManager { get; set; }
        public string Queue { get; set; }
        public string Channel { get; set; }

        public string UserID { get; set; }
        public string Password { get; set; }

        public string CertificateStore { get; set; }
        public string CipherSpec { get; set; }
        public string CipherSuite { get; set; }

        public int ReconnectWaitInterval { get; set; }
        public int IdleTimeout { get; set; }
    }
}

Payload.cs:

namespace Messaging.IBMMQ.Shared.Models
{
    public class Payload
    {
        public string CorrelationId { get; set; }
        public string Body { get; set; }
    }
}


MessageProcessing.Handler:

ProcessRequestCommand.cs:

using MediatR;
using Messaging.IBMMQ.Shared.Models;

namespace MessagingProcessing.Handler
{
    public record ProcessRequestCommand(Payload Message) : IRequest;
}


ProcessRequestCommandHandler.cs:

using MediatR;
using MessageProcessing.Shared.Interface;
using Messaging.IBMMQ.Shared.Models;
using Microsoft.Extensions.Logging;


namespace MessagingProcessing.Handler
{

    public class ProcessRequestCommandHandler : IRequestHandler<ProcessRequestCommand>
    {
        private readonly ILogger<ProcessRequestCommand> _logger;        
        private readonly IRepository _repository;        
        private readonly IETLTriggerScheduler _etlTriggerScheduler;
        private readonly IPublisher _publisher;

        public ProcessRequestCommandHandler(ILogger<ProcessRequestCommand> logger, IRepository repository, IETLTriggerScheduler etlTriggerScheduler, IPublisher publisher)
        {
            _logger = logger;
            _repository = repository;
            _etlTriggerScheduler = etlTriggerScheduler;
            _publisher = publisher;            
        }
        public async Task<Unit> Handle(ProcessRequestCommand cmd, CancellationToken ct)
        {
            try
            {
                await _repository.StagingInsert(cmd.Message, DateTime.Now, "IBM MQ", ct);
                _etlTriggerScheduler.Start();                
                _logger.LogInformation("Persisted subscribed message {0} at {1}", cmd.Message.CorrelationId, DateTime.Now);
                
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error while handling message {CorrelationId}", cmd.Message.CorrelationId);
            }

            return Unit.Value;
        }
    }
}



dbo.p_Staging_Insert:

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[p_Staging_Insert]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[p_Staging_Insert]
GO
 
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
 
CREATE PROCEDURE [dbo].[p_Staging_Insert]
(	
	@CorrelationId	NVARCHAR(100),
	@Body VARCHAR(MAX),
	@Source VARCHAR(50),
	@EnqueueUtc DATETIME 
)
AS
BEGIN
	SET NOCOUNT ON;
 
	IF NOT EXISTS (SELECT 1 FROM [dbo].IncomingStaging WHERE MessageId = @CorrelationId)
	BEGIN
		INSERT INTO dbo.IncomingStaging 
		(
			MessageId, 
			Body, 
			[Source], 
			EnqueueUtc
		)
		VALUES 
		(
			@CorrelationId, 
			@Body, 
			@Source, 
			@EnqueueUtc
		)
	END

 
END
GO 


[dbo].[p_Process_ETL]:

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[p_Process_ETL]') AND type in (N'P', N'PC'))
	DROP PROCEDURE [dbo].[p_Process_ETL]
GO
 
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
 
CREATE PROCEDURE [dbo].[p_Process_ETL]

AS
BEGIN
	SET NOCOUNT ON;
	
		INSERT INTO dbo.IncomingFinal
		(
			MessageId, 
			Body, 
			[Source], 
			EnqueueUtc
		)
		SELECT
		
			MessageId, 
			Body, 
			[Source], 
			EnqueueUtc
		
		FROM 
			dbo.IncomingStaging IST
		WHERE 
			NOT EXISTS (SELECT 1 FROM dbo.IncomingFinal IFN WHERE IFN.MessageId = IST.MessageId)

	

 
END
GO

Table Schemas:

CREATE TABLE [dbo].IncomingStaging
(
	StagingId INT IDENTITY(1,1) PRIMARY KEY,
	MessageId NVARCHAR(100) NOT NULL,
	Body VARCHAR(MAX) NULL,
	[Source] VARCHAR(50) NULL,
	EnqueueUtc DATETIME NULL
)

CREATE TABLE [dbo].IncomingFinal
(
	StagingId INT IDENTITY(1,1) PRIMARY KEY,
	MessageId NVARCHAR(100) NOT NULL,
	Body VARCHAR(MAX) NULL,
	[Source] VARCHAR(50) NULL,
	EnqueueUtc DATETIME NULL
)

