 //for inbound message processing
 public override List<string> ReadSwiftMessages(string tagCompData, FtpConfigurationElement item)
 {
     List<string> lstMessages = new List<string>();
     List<KeyValuePair<string, string>> lstMessageFilename = new List<KeyValuePair<string, string>>();
     FtpConfigurationElement ftpConfigElement = ftpConfig.FtpConfigElementColl[item.Destination];
     string InboundLocalArchivalPath = ftpConfigElement.LocalArchivalPath + Constants.CONS_INBOUNDFOLDER;
     string InboundInProgresspath = ftpConfigElement.InprogressPath + Constants.CONS_INBOUNDFOLDER;
     string[] arrFileExt = new string[] { Constants.CONS_INBOUNDMESSAGEEXT };

     //Process the the message, if message type present in App.Config.
     string[] filterMessageType = (ftpConfigElement.MessageTypes.Replace(Constants.CONS_MESSAGETYPESTART, "")).Split('|');

     //read and create string array from all messages in inbound directory
     try
     {
         //only gets the files from SFTP location
         try
         {
             SFTPClient.SftpDownloadFiles(
                 ftpConfigElement.Server,
                 ftpConfigElement.User,
                 ftpConfigElement.Password,
                 InboundInProgresspath,
                 ftpConfigElement.InboundMsgPath,
                 ftpConfigElement.InboundArchivePath,
                 ftpConfigElement.ArchiveInboundMsg,
                 ftpConfigElement.DeleteInboundMsg,
                 ftpConfigElement.FingerPrint,
                 arrFileExt,
                 item.DBName,
                 item.MessageTypes
             );
         }
         catch (Exception)
         {
             //Catch error logging completed in above function
             return lstMessages;
         }

         InboundInProgresspath = InboundInProgresspath + Constants.CONS_SINGLEBWSLASH + DateDir;

         if (Directory.Exists(InboundInProgresspath))
         {
             IEnumerable<string> arrInboundFileName = Directory.EnumerateFiles(InboundInProgresspath + Constants.CONS_SINGLEBWSLASH);
             List<string> processarrInboundFileName = new List<string>();
             string fileName = null;

             _logger.LogInfo(item.DBName + " - " + item.MessageTypes, Constants.CONS_INBOUNDPROCESS_MESSAGE_1);
             foreach (string file in arrInboundFileName)
             {
                 try
                 {
                     fileName = file.Substring(
                         InboundInProgresspath.Length + 1,
                         file.Length - (InboundInProgresspath.Length + 1)
                     );

                     ApplicationHeaderBlock applicationHeader =
                         new ApplicationHeaderBlock(DeliveryHelper.ReadFile(file));

                     if (filterMessageType.Contains(applicationHeader.MessageType))
                     {
                         lstMessageFilename.Add(
                             new KeyValuePair<string, string>(fileName, DeliveryHelper.ReadFile(file))
                         );
                         lstMessages.Add(DeliveryHelper.ReadFile(file));
                         processarrInboundFileName.Add(file);
                         _logger.LogInfoFormat(
                             item.DBName + " - " + item.MessageTypes,
                             Constants.CONS_INBOUND_PROCESSED,
                             applicationHeader.MessageType,
                             fileName
                         );
                     }
                     else
                     {
                         _logger.LogInfoFormat(
                             item.DBName + " - " + item.MessageTypes,
                             Constants.CONS_INBOUND_NOTPROCESSED,
                             applicationHeader.MessageType,
                             fileName
                         );
                     }
                 }
                 catch (Exception ex)
                 {
                     _logger.LogErrorMessage(
                         item.DBName + " - " + item.MessageTypes,
                         Constants.CONS_INBOUND_SWIFTMESSAGE_INVALID,
                         ex,
                         true,
                         "ReadSwiftMessages",
                         new string[] { "fileName" },
                         fileName
                     );
                 }
             }

             _logger.LogInfo(item.DBName + " - " + item.MessageTypes, Constants.CONS_INBOUNDPROCESS_MESSAGE_2);
             InboundSwiftMessageCollection swiftMessages =
                 new InboundSwiftMessageCollection(lstMessages, tagCompData, lstMessageFilename);

             if (swiftMessages.Count > 0)
             {
                 _logger.LogInfo(item.DBName + " - " + item.MessageTypes, Constants.CONS_INBOUNDPROCESS_MESSAGE_3);

                 try
                 {
                     SwiftInbound.UpdateInboundMessagesStatus(swiftMessages, item.DBName);
                 }
                 catch (Exception ex)
                 {
                     if (ex.Source.ToUpper().Contains("SQLEXCEPTION") || ex.Source.ToUpper().Contains("SQLCONNECTION"))
                         _logger.LogFatalMessage(
                             item.DBName + " - " + item.MessageTypes,
                             Constants.CONS_INBOUNDPROCESS_MESSAGE_5,
                             ex,
                             Constants.CONS_METHOD_UPDATEINBOUNDMESSAGESSTATUS,
                             new string[] { "DBName", "SwiftMessages" },
                             ftpConfigElement.DBName,
                             swiftMessages
                         );
                     else
                         _logger.LogErrorMessage(
                             item.DBName + " - " + item.MessageTypes,
                             Constants.CONS_INBOUNDPROCESS_MESSAGE_5,
                             ex,
                             true,
                             Constants.CONS_METHOD_UPDATEINBOUNDMESSAGESSTATUS,
                             new string[] { "DBName", "SwiftMessages" },
                             ftpConfigElement.DBName,
                             swiftMessages
                         );
                 }
                 _logger.LogInfo(item.DBName + " - " + item.MessageTypes, Constants.CONS_INBOUNDPROCESS_MESSAGE_4);
             }

             _logger.LogInfo(item.DBName + " - " + item.MessageTypes, " Inbound Messages - " + Constants.CONS_FTP_ARCHIVEFILE_START_MESSAGE);
             foreach (string file in arrInboundFileName)
             {
                 if (ftpConfigElement.RenameInboundMsg)
                 {
                     try
                     {
                         SFTPClient.SFtpRenameFile(
                             ftpConfigElement.Server,
                             ftpConfigElement.User,
                             ftpConfigElement.Password,
                             ftpConfigElement.InboundMsgPath,
                             Path.GetFileName(file),
                             Constants.CONS_OLDEXT,
                             Constants.CONS_NEWEXT,
                             ftpConfigElement.FingerPrint,
                             ftpConfigElement.MessageTypes,
                             ftpConfigElement.DBName
                         );
                     }
                     catch (Exception)
                     {
                         //Catch error logging completed in above function
                     }
                 }

                 //moves the file from SFTP location to archive SFTP location
                 if (ftpConfigElement.ArchiveInboundMsg)
                 {
                     try
                     {
                         SFTPClient.SFtpArchiveFile(
                             ftpConfigElement.Server,
                             ftpConfigElement.User,
                             ftpConfigElement.Password,
                             ftpConfigElement.InboundMsgPath,
                             ftpConfigElement.InboundArchivePath,
                             file,
                             ftpConfigElement.FingerPrint,
                             ftpConfigElement.MessageTypes,
                             ftpConfigElement.DBName
                         );
                     }
                     catch (Exception)
                     {
                         //Catch error logging completed in above function
                     }
                 }

                 DeliveryHelper.MoveFileToFolder(
                     InboundInProgresspath,
                     InboundLocalArchivalPath + Constants.CONS_SINGLEBWSLASH + DateDir + Constants.CONS_SINGLEBWSLASH,
                     file,
                     Path.GetFileName(file),
                     true,
                     item.DBName,
                     item.MessageTypes
                 );
             }
             _logger.LogInfo(item.DBName + " - " + item.MessageTypes, Constants.CONS_FTP_ARCHIVEFILE_STOP_MESSAGE);
         }
     }
     catch (Exception ex)
     {
         //Do not perform logging thrown by exceptions from inner functions
         if (ex.Message.Trim() != Constants.CONS_METHOD_SFTPDOWNLOADFILES.Trim() &&
             ex.Message.Trim() != Constants.CONS_METHOD_SFTPARCHIVEFILE.Trim())
         {
             if (ex.Source.ToUpper().Contains("WINIOERROR"))
                 _logger.LogFatalMessage(
                     item.DBName + " - " + item.MessageTypes,
                     Constants.CONS_MOVEFILETOFODER_1,
                     ex,
                     MethodBase.GetCurrentMethod()
                 );
             else
                 _logger.LogErrorMessage(
                     item.DBName + " - " + item.MessageTypes,
                     Constants.CONS_INBOUNDPROCESS_MESSAGE_6,
                     ex,
                     false,
                     MethodBase.GetCurrentMethod()
                 );
         }
     }
     return lstMessages;
 }

 private static Logger _logger = new Logger(typeof(InboundSwiftMessageCollection));

 #region inbound processing

 public InboundSwiftMessageCollection(
     List<string> _messages,
     string _tagCompData,
     List<KeyValuePair<string, string>> lstMessageFilename)
 {
     this.createSwiftMessages(_messages, _tagCompData, lstMessageFilename);
 }

 void createSwiftMessages(
     List<string> _messages,
     string _tagCompData,
     List<KeyValuePair<string, string>> lstMessageFilename)
 {
     try
     {
         string[] fileContent = null;

         foreach (string message in _messages)
         {
             fileContent = message.Split(AppConfig.MultipleINBMsgSeperator.ToCharArray());
             string filename = lstMessageFilename
                 .Where(x => x.Value.Equals(message))
                 .FirstOrDefault()
                 .Key;

             if (fileContent != null && fileContent.Length > 0)
             {
                 for (int i = 0; i < fileContent.Length; i++)
                 {
                     InboundSwiftMessage swiftMessage =
                         this.process(fileContent[i], _tagCompData, filename);

                     if (swiftMessage.IsValidMessage)
                         this.Add(swiftMessage);
                 }
             }
         }
     }
     catch (Exception ex)
     {
         _logger.LogErrorMessage("", "Error at createSwiftMessages", ex, false, null);
     }
 }

 InboundSwiftMessage process(string _message, string _tagCompData, string filename)
 {
     InboundSwiftMessage message =
         new InboundSwiftMessage(_message, _tagCompData, filename);

     return message;
 }

 #endregion

 public static void UpdateInboundMessagesStatus(
     InboundSwiftMessageCollection _messages,
     string itemDBName)
 {
     DataSet dsResult = null;

     string swiftMessageXml = null;
     StringBuilder sbSwiftMesage = new StringBuilder();
     StringBuilder sbAttributeList = new StringBuilder();
     string MessageDirection = Constants.CONS_MESSAGEDIRECTION;
     int MessageStatusId = OutboundStatusTypeData.CONS_MESSAGE_CREATED;
     string InboundMUR = string.Empty;
     string xmlSwiftData = string.Empty;
     bool blnSuccess = false;
     DataTable dtSwiftTag = new DataTable();
     string ParsedFileName = string.Empty;

     foreach (var message in _messages)
     {
         try
         {
             dtSwiftTag = Common.Common.CreateDataTable(message.Text.SwiftTag);
             dtSwiftTag.TableName = Common.Constants.CONS_TBL_TAGCOMP;

             InboundMUR = message.Text[Constants.CONS_BLOCK3TAG108] != null
                 ? message.Text[Constants.CONS_BLOCK3TAG108].TagValue
                 : string.Empty;

             sbSwiftMesage = new StringBuilder();
             sbAttributeList = new StringBuilder();
             ParsedFileName = message.FileName;

             sbSwiftMesage.Append(
                 Convert.ToString(message.Text[Constants.CONS_BLOCK4TAG20].TagValue) +
                 Constants.CONS_SEMICOLON +
                 string.Empty +
                 Constants.CONS_SEMICOLON +
                 message.MessageType +
                 Constants.CONS_SEMICOLON +
                 message.MessageText +
                 Constants.CONS_SEMICOLON +
                 MessageDirection +
                 Constants.CONS_SEMICOLON +
                 MessageStatusId +
                 Constants.CONS_SEMICOLON +
                 InboundMUR +
                 Constants.CONS_SEMICOLON +
                 message.Text[Constants.CONS_BLOCK4TAG20].TagValue +
                 Constants.CONS_SEMICOLON +
                 message.ApplicationHeaderText.RecipientAddress +
                 Constants.CONS_PIPESEPERATOR
             );

             sbAttributeList.Append(Constants.CONS_INBOUNDXMLATTR);
             swiftMessageXml = Common.Common
                 .ConvertStringToXML(
                     sbSwiftMesage.ToString(),
                     sbAttributeList.ToString(),
                     Convert.ToChar(Constants.CONS_SEMICOLON)
                 )
                 .ToString();

             xmlSwiftData = Common.Common.GetXMLData(dtSwiftTag);

             swiftMessageXml = swiftMessageXml.Replace("'", "&apos;");
             xmlSwiftData = xmlSwiftData.Replace("'", "&apos;");

             dsResult = SWIFTInbound.SaveInboundMessage(
                 message.MessageType,
                 ParsedFileName,
                 ModifiedBy,
                 itemDBName,
                 xmlSwiftData,
                 swiftMessageXml,
                 ref blnSuccess
             );

             if (dsResult != null && dsResult.Tables.Count > 0)
             {
                 bool isSuccess =
                     Convert.ToBoolean(dsResult.Tables[0].Rows[0][Constants.COL_ISSUCESS]);

                 if (!isSuccess)
                     _logger.LogErrorMessage(
                         itemDBName + " - MT" + message.MessageType,
                         Constants.CONS_ERROR_SAVING_INBOUNDFILE,
                         null,
                         true,
                         Constants.CONS_METHOD_SAVEINBOUNDMESSAGE,
                         new string[] { "ParsedFileName", "Error Message" },
                         ParsedFileName,
                         Convert.ToString(dsResult.Tables[0].Rows[0][Constants.CONS_COL_MESSAGE_CODE])
                     );
                 else
                     _logger.LogInfoFormat(
                         itemDBName + " - MT" + message.MessageType,
                         Constants.CONS_SAVED_INBOUNDFILE + ParsedFileName
                     );
             }
         }
         catch (Exception ex)
         {
             if (ex.Message.Trim() != Constants.CONS_METHOD_SAVEINBOUNDMESSAGE.Trim())
             {
                 _logger.LogErrorMessage(
                     itemDBName + " - MT" + message.MessageType,
                     Constants.CONS_PARSE_INBOUND_MESSAGE_ERROR,
                     ex,
                     true,
                     Constants.CONS_METHOD_UPDATEINBOUNDMESSAGESSTATUS,
                     new string[] { "ParsedFileName" },
                     ParsedFileName
                 );
             }
         }
     }
 }

 public static DataSet SaveInboundMessage(
     string MessageType,
     string ParsedFileName,
     string UserId,
     string applicationDBName,
     string xmlSwiftData,
     string xmlInboundSwiftData,
     ref bool blnSuccess)
 {
     return SwiftInboundRepository.SaveInboundMessage(
         MessageType,
         ParsedFileName,
         UserId,
         applicationDBName,
         xmlSwiftData,
         xmlInboundSwiftData,
         ref blnSuccess
     );
 }

public SwiftInboundMQ Create(string swiftInboundMQPayload)
{
    try
    {
        var swiftInboundMQPayloadArr = swiftInboundMQPayload.Split('|');
        SwiftInboundMQ swiftInboundMQ = new()
        {
            CorrelationID = swiftInboundMQPayloadArr[0],                    
            MessageText = swiftInboundMQPayload
        };
        return swiftInboundMQ;
    }
    catch
    {
        throw;
    }

}

public async Task ConsumeMessagesAsync(CancellationToken ct)
{
    try
    {
        foreach (var swiftInboundPayload in _swiftInboundMQSubscriber.ReadMessages(ct))
        {
            try
            {
                _logger.LogInformation("Consumed swift inbound MQ message. Payload: {SwiftInboundPayload}", swiftInboundPayload);
                var swiftInboundMQ = _swiftInboundFactory.Create(swiftInboundPayload);
                await _swiftInboundRepository.AddAsync(swiftInboundMQ, ct);
            }
            catch (Exception payloadEx)
            {
                _logger.LogError(payloadEx, "Error while processing messages. Payload: {SwiftInboundPayload} ", swiftInboundPayload);
            }
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error while processing position messages.");
    }

}
