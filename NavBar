public InboundSwiftMessageCollection ReadSwiftMessagesFromMQ(
    string mqPayload,
    string correlationId,
    string tagCompData,
    FtpConfigurationElement item)
{
    List<string> lstMessages = new();
    List<KeyValuePair<string, string>> lstMessageFilename = new();

    ApplicationHeaderBlock applicationHeader =
        new ApplicationHeaderBlock(mqPayload);

    string[] filterMessageType =
        (item.MessageTypes.Replace(Constants.CONS_MESSAGETYPESTART, ""))
        .Split('|');

    if (!filterMessageType.Contains(applicationHeader.MessageType))
        return new InboundSwiftMessageCollection();

    lstMessages.Add(mqPayload);
    lstMessageFilename.Add(
        new KeyValuePair<string, string>(correlationId, mqPayload));

    // Parsing only â€“ no DB call
    return new InboundSwiftMessageCollection(
        lstMessages,
        tagCompData,
        lstMessageFilename);
}



public async Task ConsumeMessagesAsync(CancellationToken ct)
{
    try
    {
        foreach (var mqMessage in _swiftInboundMQSubscriber.ReadMessages(ct))
        {
            try
            {
                var swiftMessages =
                    _swiftInboundFactory.ReadSwiftMessagesFromMQ(
                        mqMessage.Payload,
                        mqMessage.CorrelationId,
                        _tagCompData,
                        _ftpConfigurationElement);

                foreach (var swiftMessage in swiftMessages)
                {
                    var entity = MapToSwiftInboundMQ(swiftMessage);
                    await _swiftInboundRepository.AddAsync(entity, ct);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(
                    ex,
                    "Error processing MQ message. CorrelationId: {CorrelationId}",
                    mqMessage.CorrelationId
                );
            }
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error while consuming MQ messages.");
    }
}



private SwiftInboundMQ MapToSwiftInboundMQ(InboundSwiftMessage message)
{
    return new SwiftInboundMQ
    {
        CorrelationID = message.FileName,
        MessageType = message.MessageType,
        ProcessedFileName = message.FileName,
        UserID = ModifiedBy,
        IsSuccess = true,

        InboundSwiftMessageData =
            Common.Common.GetXMLData(
                Common.Common.CreateDataTable(message.Text.SwiftTag)),

        SwiftMessageData =
            Common.Common.ConvertStringToXML(
                BuildSwiftMessageString(message),
                Constants.CONS_INBOUNDXMLATTR,
                Convert.ToChar(Constants.CONS_SEMICOLON)
            ).ToString()
    };
}



private string BuildSwiftMessageString(InboundSwiftMessage message)
{
    return
        message.Text[Constants.CONS_BLOCK4TAG20].TagValue +
        Constants.CONS_SEMICOLON +
        string.Empty +
        Constants.CONS_SEMICOLON +
        message.MessageType +
        Constants.CONS_SEMICOLON +
        message.MessageText +
        Constants.CONS_SEMICOLON +
        Constants.CONS_MESSAGEDIRECTION +
        Constants.CONS_SEMICOLON +
        OutboundStatusTypeData.CONS_MESSAGE_CREATED +
        Constants.CONS_SEMICOLON +
        (message.Text[Constants.CONS_BLOCK3TAG108]?.TagValue ?? string.Empty) +
        Constants.CONS_SEMICOLON +
        message.Text[Constants.CONS_BLOCK4TAG20].TagValue +
        Constants.CONS_SEMICOLON +
        message.ApplicationHeaderText.RecipientAddress +
        Constants.CONS_PIPESEPERATOR;
}
