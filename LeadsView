// ISwiftInboundFactory (Interface or Abstract Class)
// Returns a list to handle cases where one MQ payload contains multiple SWIFT messages (separated by '$')
List<SwiftInboundMQ> ReadSwiftMessages(string swiftInboundPayload, string dbName, string tagCompData);






public class SwiftInboundFactory(ILogger<SwiftInboundFactory> logger) : ISwiftInboundFactory
{        
    private readonly ILogger<SwiftInboundFactory> _logger = logger;        

    // *** IMPORTANT: The old signature is likely obsolete and can be removed/updated:
    // public override List<string> ReadSwiftMessages(string tagCompData, FtpConfigurationElement item)
    // The implementation below replaces its core parsing function.

    public List<SwiftInboundMQ> ReadSwiftMessages(string swiftInboundPayload, string dbName, string tagCompData)
    {
        List<SwiftInboundMQ> processedMessages = new List<SwiftInboundMQ>();
        List<KeyValuePair<string, string>> lstMessageFilename = new List<KeyValuePair<string, string>>();
        List<string> lstRawMessages = new List<string>();

        try
        {
            // 1. Separate potential multiple messages within the payload (as per your old logic)
            string[] fileContent = swiftInboundPayload.Split('$'.ToCharArray());

            if (fileContent != null && fileContent.Length > 0)
            {
                foreach (string message in fileContent)
                {
                    if (string.IsNullOrWhiteSpace(message)) continue;

                    // 2. Mock a FileName/Unique ID since it's an MQ message now
                    string mockFileName = Guid.NewGuid().ToString("N") + ".txt"; 

                    // 3. Process the raw message into the old InboundSwiftMessage structure (for parsing logic)
                    InboundSwiftMessage inboundMessage = ProcessRawMessage(message, tagCompData, mockFileName);
                    
                    if (inboundMessage.IsValidMessage)
                    {
                        // 4. Map the parsed message to the new DTO (SwiftInboundMQ)
                        SwiftInboundMQ mqMessage = MapToSwiftInboundMQ(inboundMessage, dbName);
                        processedMessages.Add(mqMessage);

                        _logger.LogInformation(dbName + " - MT" + inboundMessage.MessageType, "Parsed inbound swift message. Mock File - {0}", mockFileName);
                    }
                    else
                    {
                        _logger.LogInformation(dbName, "Discarded message due to invalid format.");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(dbName, "Exception in ReadSwiftMessages while processing MQ payload.", ex);
            // Optionally rethrow or return empty list based on error handling policy
        }
        
        return processedMessages;
    } 

    // Helper method to keep your core parsing logic isolated
    private InboundSwiftMessage ProcessRawMessage(string _message, string _tagCompData, string filename)
    {
        // This is where your old InboundSwiftMessage logic lives
        return new InboundSwiftMessage(_message, _tagCompData, filename); 
    }

    // Helper method to map the old parsed object to the new DTO 
    private SwiftInboundMQ MapToSwiftInboundMQ(InboundSwiftMessage message, string dbName)
    {
        // This mapping logic is based on the logic found in your old UpdateInboundMessagesStatus
        
        // 1. Map Swift Tags (TblTagComp)
        DataTable dtSwiftTag = LAVA.SwiftInbound.Subscriber.Core.Common.CreateDataTable(message.Text.SwiftTag);
        dtSwiftTag.TableName = "TblTagComp";
        string xmlSwiftData = LAVA.SwiftInbound.Subscriber.Core.Common.GetXMLData(dtSwiftTag);
        xmlSwiftData = xmlSwiftData.Replace("'", "&apos;"); // Escape single quotes

        // 2. Map Inbound Message Data (Header/Summary XML)
        StringBuilder sbSwiftMesage = new StringBuilder();
        StringBuilder sbAttributeList = new StringBuilder();
        // ... (Build sbSwiftMesage and sbAttributeList as per your existing logic) ...
        // Example logic from your old code:
        sbSwiftMesage.Append(
            message.Text["20"].TagValue + ";" + // SwiftMessageId
            string.Empty + ";" + // RelatedSwiftMsgId
            message.MessageType + ";" + // SwiftMsgType
            message.MessageText + ";" + // MessageText
            "Inbound" + ";" + // MessageDirection
            45 + ";" + // MessageStatusId
            (message.Text["{108:"] != null ? message.Text["{108:"].TagValue : string.Empty) + ";" + // InboundMUR
            message.Text["20"].TagValue + ";" + // InboundReference
            message.ApplicationHeaderText.RecipientAddress + "|" // RecipientAddress
        );

        sbAttributeList.Append("SwiftMessageId|RelatedSwiftMsgId|SwiftMsgType|MessageText|MessageDirection|MessageStatusId|InboundMUR|InboundReference|RecipientAddress");
        string swiftMessageXml = LAVA.SwiftInbound.Subscriber.Core.Common.ConvertStringToXML(sbSwiftMesage.ToString(), sbAttributeList.ToString(), ';').ToString();
        swiftMessageXml = swiftMessageXml.Replace("'", "&apos;"); // Escape single quotes

        // 3. Create and populate the DTO
        return new SwiftInboundMQ
        {
            MessageType = message.MessageType,
            InboundSwiftMessageData = swiftMessageXml,
            UserID = "dcolaco", // Hardcoded user ID from your original code
            SwiftMessageData = xmlSwiftData,
            IsSuccess = true, // Default to true upon successful parsing
            ProcessedFileName = message.FileName, // Mocked GUID
            CorrelationID = message.FileName // Use filename as Correlation ID for traceability
        };
    }
}





public class SwiftInboundConsumer(ILogger<SwiftInboundConsumer> logger,
                             ISubscriber swiftInboundMQSubscriber,
                             ISwiftInboundFactory swiftInboundMQFactory,
                             IRepository<SwiftInboundMQ> swiftInboundMQRepository) : ISwiftInboundConsumer
{
    private readonly ISubscriber _swiftInboundMQSubscriber = swiftInboundMQSubscriber;
    private readonly IRepository<SwiftInboundMQ> _swiftInboundRepository = swiftInboundMQRepository;
    private readonly ISwiftInboundFactory _swiftInboundFactory = swiftInboundMQFactory;
    private readonly ILogger<SwiftInboundConsumer> _logger = logger;

    public async Task ConsumeMessagesAsync(CancellationToken ct)
    {
        // NOTE: You need a way to get 'dbName' and 'tagCompData' here, 
        // perhaps from a configuration service or hardcoded context.
        // Assuming they are loaded from a configuration or dependency:
        string contextDbName = "LAVA"; 
        string contextTagCompData = "{...}"; // Replace with actual value

        try
        {
            foreach (var swiftInboundPayload in _swiftInboundMQSubscriber.ReadMessages(ct))
            {
                try
                {
                    _logger.LogInformation("Consumed swift inbound MQ message. Payload: {SwiftInboundPayload}", swiftInboundPayload.Substring(0, Math.Min(100, swiftInboundPayload.Length)) + "...");
                    
                    // 1. Get a list of fully mapped DTOs from the factory
                    List<SwiftInboundMQ> swiftMessagesToPersist = _swiftInboundFactory.ReadSwiftMessages(
                        swiftInboundPayload, 
                        contextDbName, 
                        contextTagCompData
                    );

                    // 2. Persist each message DTO
                    foreach (var swiftInboundMQ in swiftMessagesToPersist)
                    {
                        await _swiftInboundRepository.AddAsync(swiftInboundMQ, ct);
                    }
                }
                catch (Exception payloadEx)
                {
                    _logger.LogError(payloadEx, "Error while processing messages. Payload: {SwiftInboundPayload} ", swiftInboundPayload);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error while processing position messages.");
        }
    }
}





public async Task AddAsync(SwiftInboundMQ swiftInboundMQ, CancellationToken ct)
{
    _logger.LogInformation("Add MQ swift inbound message to LAVA db. CorrelationID: {CorrelationID}", swiftInboundMQ.CorrelationID);
    try
    {
        // The 'using' statement handles connection closing/disposal automatically.
        using var conn = new SqlConnection(_connString);
        using (var cmd = new SqlCommand("dbo.p_ProcessInboundSwiftMessage_Test", conn))
        {
            cmd.CommandType = System.Data.CommandType.StoredProcedure;
            cmd.Parameters.AddWithValue("@pMsgType", swiftInboundMQ.MessageType);
            cmd.Parameters.AddWithValue("@xmlInboundSwiftMessageData", swiftInboundMQ.InboundSwiftMessageData);
            cmd.Parameters.AddWithValue("@pUserId", swiftInboundMQ.UserID);
            cmd.Parameters.AddWithValue("@pXMLSwiftMessageData", swiftInboundMQ.SwiftMessageData);
            cmd.Parameters.AddWithValue("@IsSuccess", swiftInboundMQ.IsSuccess);
            cmd.Parameters.AddWithValue("@pProcessedFileName", swiftInboundMQ.ProcessedFileName);
            
            await conn.OpenAsync(ct);
            await cmd.ExecuteNonQueryAsync(ct);
        }
        // Removed the extra 'await conn.CloseAsync();' and the unnecessary semicolon.
    }
    catch (Exception ex)
    {
        _logger.LogError("Error while adding MQ swift inbound message to LAVA db. CorrelationID: {CorrelationID}. Exception: {ErrorMsg}",
                        swiftInboundMQ.CorrelationID, ex.Message);
        throw;
    }
}
